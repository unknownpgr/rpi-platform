#!/usr/bin/env python3

import json
import os
def parse_type(type_str):
    if '[' in type_str:
        type, size = type_str.split('[')
        size = int(size.strip(']'))
        return {
            "type": type,
            "size": size
        }
    else:
        return {
            "type": type_str,
        }

def parse_state_definition(file_path):
    with open(file_path, 'r') as file:
        text = file.read()

    sections = text.split("---")
    if len(sections) != 2:
        print("Invalid state definition")
        exit(1)

    states = []
    lines = sections[0].split("\n")
    for line in lines:
        if line.strip() == "":
            continue

        if line.startswith("//"):
            continue

        states.append(line.strip().upper())
        

    definition = []
    lines = sections[1].split("\n")
    for line in lines:
        if line.strip() == "":
            continue

        if line.startswith("//"):
            continue
        
        parts = line.split()
        if len(parts) != 2:
            print(f"Invalid line: {line}")
            exit(1)

        name = parts[0]
        type = parts[1]

        definition.append((name, parse_type(type)))

    return states,definition

def to_c_type(type):
    if type == "uint8":
        return "uint8_t"
    elif type == "uint16":
        return "uint16_t"
    elif type == "uint32":
        return "uint32_t"
    elif type == "double":
        return "double"
    else:
        print(f"Unknown type: {type}")
        exit(1)

def generate_state_struct(definition):
    output = "typedef struct\n{\n"

    for name, type in definition:
        if 'size' in type:
            output += f"  {to_c_type(type['type'])} {name}[{type['size']}];\n"
        else:
            output += f"  {to_c_type(type['type'])} {name};\n"

    output += "} state_t;\n"
    return output


def generate_state_print(definition):
    '''
    Generate a function that prints the offset of each field in the state struct
    '''
    output = "void state_print_offsets(state_t *state, char *buffer)\n{\n"
    output += '  buffer += sprintf("STATE_DEFINITION_START\\n");\n'
    output += "  uint8_t base_address = (uint8_t *)state;\n"
    for name, _ in definition:
        output += f"  buffer += sprintf(buffer, \"{name}: %ld\\n\", (uint8_t *)(&state->{name}) - base_address);\n"
    output += '  buffer += sprintf("STATE_DEFINITION_END\\n");\n'
    output += "}\n"
    return output

def main():
    os.chdir(os.path.dirname(os.path.abspath(__file__)) + "/../")

    states, definition = parse_state_definition("state-definition")
    struct_str = generate_state_struct(definition)
    print_str = generate_state_print(definition)

    with open("src-main/core/state.h", "w") as file:
        file.write("// This file is automatically generated by state-gen script\n")
        file.write("// Do not edit this file manually\n")
        file.write("#pragma once\n\n")
        file.write("#include <stdint.h>\n\n")
        for i, state in enumerate(states):
            file.write(f"#define EM_STATE_{state} 0x{1<<(i+1):02x}\n")
        file.write("\n")
        file.write(struct_str)
        file.write("\n")
        file.write("void state_print_offsets(state_t *state, char *buffer);\n")
        file.write("extern state_t state;\n")
    with open("src-main/core/state.c", "w") as file:
        file.write("// This file is automatically generated by state-gen script\n")
        file.write("// Do not edit this file manually\n")
        file.write("#include \"state.h\"\n\n")
        file.write(print_str)
    
if __name__ == "__main__":
    main()